name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ dev ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}"

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'

      - name: Restart docker
        run: sudo service docker restart
        
      - name: Sync and Push to Aliyun
        id: sync_step
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0

          while IFS= read -r line || [ -n "$line" ]; do
              [[ -z "$line" ]] || [[ "$line" =~ ^\s*# ]] && continue
              
              raw_image=$(echo "$line" | awk '{print $NF}')
              full_image="${raw_image%%@*}"
              image_name_tag=$(echo "$full_image" | awk -F'/' '{print $NF}')
              
              if [[ "$full_image" == *"/"* ]]; then
                  org_part=$(echo "$full_image" | sed "s|\/${image_name_tag}||" | tr '/' '_')
              else
                  org_part="library"
              fi
              
              new_repo_name="${org_part}_${image_name_tag}"
              target_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$new_repo_name"

              # æ£€æŸ¥é•œåƒæ˜¯å¦å­˜åœ¨
              if skopeo inspect docker://$target_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  echo ">>> Skip: $image_name_tag"
                  continue
              fi

              # æ‰§è¡ŒåŒæ­¥
              if docker pull "$full_image" && docker tag "$full_image" "$target_image" && docker push "$target_image"; then
                  docker rmi "$full_image" "$target_image"
                  # åªæœ‰æˆåŠŸçš„æ‰åŠ å…¥ SUMMARY
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ ${image_name_tag}"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                  # åªæœ‰å¤±è´¥çš„æ‰åŠ å…¥ SUMMARY
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ ${image_name_tag} (æ¨é€å¤±è´¥)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
              fi
          done < images.txt

          # å†™å…¥ç¯å¢ƒå˜é‡
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            echo -e "$SYNC_SUMMARY"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then exit 0; fi

          # 1. å‡†å¤‡æ•°æ®
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          S_RESULT="${{ env.SYNC_RESULT }}"
          
          # 2. é€»è¾‘åˆ¤å®šï¼šæ ¹æ®æ‰§è¡Œæƒ…å†µè®¾è®¡ä¸åŒçš„æ˜¾ç¤ºå†…å®¹
          if [ "$F_COUNT" -gt 0 ]; then
              STATUS_TITLE="Dockeré•œåƒåŒæ­¥ï¼šåŒæ­¥å¼‚å¸¸"
              MAIN_MSG="âŒ è­¦å‘Šï¼šéƒ¨åˆ†é•œåƒåŒæ­¥å¤±è´¥ï¼Œè¯·åŠæ—¶å¤„ç†ã€‚"
              DETAIL_TITLE="å¤±è´¥æ—¥å¿—ï¼š"
              DETAIL_CONTENT="$S_RESULT"
          elif [ "$S_COUNT" -gt 0 ]; then
              STATUS_TITLE="Dockeré•œåƒåŒæ­¥ï¼šä»»åŠ¡æˆåŠŸ"
              MAIN_MSG="âœ… æœ¬æ¬¡æ–°å¢åŒæ­¥é•œåƒï¼š$S_COUNT ä¸ª"
              DETAIL_TITLE="æ–°å¢æ¸…å•ï¼š"
              DETAIL_CONTENT="$S_RESULT"
          else
              STATUS_TITLE="Dockeré•œåƒåŒæ­¥ï¼šä¿æŒæœ€æ–°"
              MAIN_MSG="â˜• æš‚æ— æ–°é•œåƒéœ€è¦åŒæ­¥ï¼Œä¸€åˆ‡å·²æ˜¯æœ€æ–°ã€‚"
              DETAIL_TITLE="æ£€æŸ¥çŠ¶æ€ï¼š"
              DETAIL_CONTENT="æœªå‘ç°å˜æ›´é¡¹"
          fi
    
          PAYLOAD=$(jq -n \
            --arg title "$STATUS_TITLE" \
            --arg msg "$MAIN_MSG" \
            --arg d_title "$DETAIL_TITLE" \
            --arg d_content "$DETAIL_CONTENT" \
            --arg url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{
              msg_type: "post",
              content: {
                post: {
                  zh_cn: {
                    title: $title,
                    content: [
                      [{tag: "text", text: "--------------------------------"}],
                      [{tag: "text", text: $msg}],
                      [{tag: "text", text: $d_title}],
                      [{tag: "text", text: $d_content}],
                      [{tag: "text", text: "\n"}],
                      [{tag: "a", text: "ğŸ” æŸ¥çœ‹ GitHub Action æ‰§è¡Œæ—¥å¿—", href: $url}]
                    ]
                  }
                }
              }
            }')

          curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.WEBHOOK_URL }}"
