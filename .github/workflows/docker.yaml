name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ dev ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # åœ¨ Secrets ä¸­é…ç½®é£ä¹¦æˆ–ä¼å¾®åœ°å€

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'

      - name: Restart docker
        run: sudo service docker restart

        
      - name: Sync and Push to Aliyun
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0

          while IFS= read -r line || [ -n "$line" ]; do
              [[ -z "$line" ]] || [[ "$line" =~ ^\s*# ]] && continue
              
              raw_image=$(echo "$line" | awk '{print $NF}')
              full_image="${raw_image%%@*}"
              image_name_tag=$(echo "$full_image" | awk -F'/' '{print $NF}')
              
              if [[ "$full_image" == *"/"* ]]; then
                  org_part=$(echo "$full_image" | sed "s|\/${image_name_tag}||" | tr '/' '_')
              else
                  org_part="library"
              fi
              
              new_repo_name="${org_part}_${image_name_tag}"
              target_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$new_repo_name"

              if skopeo inspect docker://$target_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  echo ">>> Skip: $image_name_tag"
                  continue
              fi

              if docker pull "$full_image" && docker tag "$full_image" "$target_image" && docker push "$target_image"; then
                  docker rmi "$full_image" "$target_image"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nâœ¨ ${image_name_tag}"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                  SYNC_SUMMARY="${SYNC_SUMMARY}\nğŸš¨ ${image_name_tag} (å¤±è´¥)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
              fi
          done < images.txt

          # ç¡®ä¿å˜é‡è¢«æ­£ç¡®å¯¼å‡º
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          
          # å¤„ç†å¤æ‚çš„ SUMMARY å­—ç¬¦ä¸²ï¼Œé˜²æ­¢æ¢è¡Œç¬¦ä¸¢å¤±
          {
            echo "SYNC_RESULT<<EOF"
            echo -e "$SYNC_SUMMARY"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then echo "æœªé…ç½® Webhook"; exit 0; fi

          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          S_RESULT="${{ env.SYNC_RESULT }}"

          # 1. åŠ¨æ€è®¾å®šå¡ç‰‡é¢œè‰²å’Œå›¾æ ‡
          # è“è‰²-info(1), ç»¿è‰²-success(3), çº¢è‰²-error(4), æ©™è‰²-warning(2)
          if [ "$F_COUNT" -gt 0 ]; then
              THEME="red"
              TITLE="ğŸš¨ Docker é•œåƒåŒæ­¥å¼‚å¸¸"
              STATUS_TXT="æ£€æµ‹åˆ°åŒæ­¥è¿‡ç¨‹ä¸­å­˜åœ¨å¤±è´¥ä»»åŠ¡ï¼Œè¯·æ’æŸ¥ã€‚"
          elif [ "$S_COUNT" -gt 0 ]; then
              THEME="green"
              TITLE="âœ… Docker é•œåƒåŒæ­¥æˆåŠŸ"
              STATUS_TXT="é•œåƒå·²æˆåŠŸæ¨é€è‡³é˜¿é‡Œäº‘ç§æœ‰ä»“åº“ã€‚"
          else
              THEME="blue"
              TITLE="â„¹ï¸ Docker é•œåƒåŒæ­¥å®Œæˆ"
              STATUS_TXT="æ‰«æå®Œæˆï¼šæš‚æ— æ–°é•œåƒéœ€è¦åŒæ­¥ã€‚"
              S_RESULT="æœªå‘ç°å˜æ›´"
          fi

          # 2. æ„é€ å¡ç‰‡ Markdown å†…å®¹
          # ä½¿ç”¨å¡ç‰‡æ¨¡å¼å¯ä»¥å®Œç¾è§£å†³æ¢è¡Œç¬¦æ˜¾ç¤ºé—®é¢˜
          CARD_CONTENT="**ğŸ“… ä»»åŠ¡æ—¶é—´**: $(date '+%Y-%m-%d %H:%M:%S')\n**ğŸ“ ä»»åŠ¡çŠ¶æ€**: $STATUS_TXT\n\n**ğŸ“¦ æ–°å¢é•œåƒæ¸…å•**:\n${S_RESULT:-æ— }\n\n**ğŸ“Š æ•°æ®ç»Ÿè®¡**:\n- æˆåŠŸæ•°é‡: <font color='green'>**$S_COUNT**</font>\n- å¤±è´¥æ•°é‡: <font color='red'>**$F_COUNT**</font>"

          # 3. ä½¿ç”¨ jq æ„é€ é£ä¹¦å¡ç‰‡ JSON (äº¤äº’å¼å¡ç‰‡ç±»å‹)
          PAYLOAD=$(jq -n \
            --arg title "$TITLE" \
            --arg theme "$THEME" \
            --arg content "$CARD_CONTENT" \
            --arg url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{
              msg_type: "interactive",
              card: {
                header: {
                  template: $theme,
                  title: { tag: "plain_text", content: $title }
                },
                elements: [
                  {
                    tag: "div",
                    text: { tag: "lark_md", content: $content }
                  },
                  {
                    tag: "hr"
                  },
                  {
                    tag: "action",
                    actions: [
                      {
                        tag: "button",
                        text: { tag: "plain_text", content: "ğŸ” æŸ¥çœ‹æ—¥å¿—è¯¦æƒ…" },
                        type: "default",
                        url: $url
                      }
                    ]
                  }
                ]
              }
            }')

          # 4. æ‰§è¡Œå‘é€
          curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.WEBHOOK_URL }}"
