name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'images.txt'
  # 新增：每天北京时间凌晨3点运行（UTC时间19:00，因为UTC+8=北京时间）
  schedule:
    - cron: '0 19 * * *'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # 在 Secrets 中配置飞书或企微地址

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Maximize build space (增强版)
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 4096          # 增加根目录预留空间
          swap-size-mb: 2048             # 增大交换空间
          remove-dotnet: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'          # 移除 CodeQL
          remove-android: 'true'         # 移除 Android SDK
          remove-docker-images: 'true'   # 移除预安装的 Docker 镜像
          build-mount-path: '/var/lib/docker/'

      - name: 清理 Docker 缓存和旧镜像 (预清理)
        run: |
          # 显示当前磁盘使用情况
          df -h
          # 停止 Docker 服务
          sudo systemctl stop docker
          # 清理 Docker 所有数据
          sudo rm -rf /var/lib/docker/*
          sudo rm -rf /var/lib/containerd/*
          # 重启 Docker
          sudo systemctl start docker
          # 再次检查磁盘空间
          df -h

      - name: 配置 Docker 优化 (减少空间占用)
        run: |
          # 配置 Docker 使用 overlay2 并设置临时目录
          sudo mkdir -p /etc/docker
          echo '{
            "storage-driver": "overlay2",
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            }
          }' | sudo tee /etc/docker/daemon.json
          sudo systemctl daemon-reload
          sudo systemctl restart docker
          # 验证 Docker 状态
          docker info | grep -E 'Space|Driver|Size'

      - name: Sync and Push to Aliyun
        id: sync_step
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          
          # 定义清理函数 (无论成功失败都清理)
          cleanup_image() {
            local img=$1
            if docker images -q "$img" > /dev/null; then
              docker rmi -f "$img" > /dev/null 2>&1 || true
            fi
          }
          
          while IFS= read -r line || [ -n "$line" ]; do
              # 跳过空行和注释行
              [[ -z "$line" ]] || [[ "$line" =~ ^\s*# ]] && continue
              
              # 显示当前磁盘使用情况 (便于排查)
              echo "=== 当前磁盘使用情况 ==="
              df -h /
              docker system df
              
              raw_image=$(echo "$line" | awk '{print $NF}')
              full_image="${raw_image%%@*}"
              image_name_tag=$(echo "$full_image" | awk -F'/' '{print $NF}')
              
              if [[ "$full_image" == *"/"* ]]; then
                  org_part=$(echo "$full_image" | sed "s|\/${image_name_tag}||" | tr '/' '_')
              else
                  org_part="library"
              fi
              
              new_repo_name="${org_part}_${image_name_tag}"
              target_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$new_repo_name"
              
              # 检查镜像是否已存在
              if skopeo inspect docker://$target_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  echo ">>> Skip: $image_name_tag (已存在)"
                  continue
              fi
              
              # 执行同步
              if docker pull "$full_image" && docker tag "$full_image" "$target_image" && docker push "$target_image"; then
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ ${image_name_tag}"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 ${image_name_tag} (推送失败)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
              fi
              
              # 强制清理当前镜像 (无论成功失败)
              cleanup_image "$full_image"
              cleanup_image "$target_image"
              
              # 额外清理 Docker 无用资源
              docker system prune -af > /dev/null 2>&1
              docker volume prune -f > /dev/null 2>&1
              
          done < images.txt
          
          # 最终清理所有 Docker 资源
          docker system prune -af
          docker volume prune -f
          
          # 写入环境变量
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            echo -e "$SYNC_SUMMARY"
            echo 'EOF'
          } >> $GITHUB_ENV
          
          # 最后检查磁盘空间
          echo "=== 最终磁盘使用情况 ==="
          df -h
          docker system df

      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then exit 0; fi
          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}
          
          # 1. 判定标题和主状态
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="❌ 阿里云镜像同步失败"
              CONTENT="⚠️ 警告：有 $F_COUNT 个镜像同步出现异常，请及时检查。"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="✅ 阿里云镜像同步成功"
              CONTENT="本次新增同步镜像如下："
          else
              TITLE="☕ 同步任务完成 (无新镜像)"
              CONTENT="检测到 images.txt 中暂无新镜像需要同步。"
          fi
          
          # 2. 组装最终文本
          RAW_TEXT=$(cat <<EOF
          $TITLE
          ━━━━━━━━━━━━━━━━
          $CONTENT
          ${{ env.SYNC_RESULT }}
          📊 统计: 成功 $S_COUNT | 失败 $F_COUNT
          🔗 详情: [查看 GitHub Action 日志](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )
          
          # 3. 发送通知
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          curl -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" "${{ secrets.WEBHOOK_URL }}"