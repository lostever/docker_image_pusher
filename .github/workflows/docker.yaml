name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ dev ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # 在 Secrets 中配置飞书或企微地址

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          build-mount-path: '/var/lib/docker/'

      - name: Restart docker
        run: sudo service docker restart

      - name: Sync and Push to Aliyun
        id: sync_step
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0

          while IFS= read -r line || [ -n "$line" ]; do
              [[ -z "$line" ]] || [[ "$line" =~ ^\s*# ]] && continue
              
              raw_image=$(echo "$line" | awk '{print $NF}')
              full_image="${raw_image%%@*}"
              image_name_tag=$(echo "$full_image" | awk -F'/' '{print $NF}')
              
              if [[ "$full_image" == *"/"* ]]; then
                  org_part=$(echo "$full_image" | sed "s|\/${image_name_tag}||" | tr '/' '_')
              else
                  org_part="library"
              fi
              
              new_repo_name="${org_part}_${image_name_tag}"
              target_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$new_repo_name"

              echo "同步中: $full_image -> $target_image"

              # 检查是否存在
              if skopeo inspect docker://$target_image --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" > /dev/null 2>&1; then
                  SYNC_SUMMARY="$SYNC_SUMMARY\n⚪ $image_name_tag (跳过)"
                  continue
              fi

              if docker pull "$full_image" && docker tag "$full_image" "$target_image" && docker push "$target_image"; then
                  docker rmi "$full_image" "$target_image"
                  SYNC_SUMMARY="$SYNC_SUMMARY\n✅ $image_name_tag"
                  ((SUCCESS_COUNT++))
              else
                  SYNC_SUMMARY="$SYNC_SUMMARY\n❌ $image_name_tag (失败)"
                  ((FAILURE_COUNT++))
              fi
          done < images.txt

          # 将结果存入环境变量，供下一步发送通知使用
          echo "SYNC_RESULT<<EOF" >> $GITHUB_ENV
          echo -e "$SYNC_SUMMARY" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "$WEBHOOK_URL" ]; then echo "未配置 Webhook，跳过通知"; exit 0; fi

          # 构建标题
          if [ "${{ job.status }}" == "success" ] && [ "${{ env.FAILURE_COUNT }}" -eq "0" ]; then
            TITLE="✅ 阿里云镜像同步成功"
          else
            TITLE="⚠️ 阿里云镜像同步完成 (含失败/异常)"
          fi

          # 构建纯文本内容
          RAW_CONTENT=$(cat <<EOF
          $TITLE

          同步详情:
          ${{ env.SYNC_RESULT }}

          总计: 成功 ${{ env.SUCCESS_COUNT }} / 失败 ${{ env.FAILURE_COUNT }}
          详情: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF
          )

          # --arg 把 shell 变量传给 jq
          PAYLOAD=$(jq -n --arg content "$RAW_CONTENT" \
            '{
              msg_type: "text",
              content: {
                text: $content
              }
            }')

          echo "Sending payload to Feishu..."
          curl -X POST -H "Content-Type: application/json" \
            -d "$PAYLOAD" "$WEBHOOK_URL"
